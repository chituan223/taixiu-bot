<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8" />
    <title>D·ª± ƒëo√°n LUCKY WIN</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <link rel="icon" href="robot_icon.gif" type="image/png" />
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700&display=swap" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet" />

    <script>
        // Anti-DevTools Script (Gi·ªØ nguy√™n)
        (function() {
            const devtools = { isOpen: false, orientation: undefined };
            const threshold = 160;
            const emitEvent = (isOpen, orientation) => {
                window.dispatchEvent(new CustomEvent('devtoolschange', { detail: { isOpen, orientation } }));
            };
            const main = ({emitEvents = true} = {}) => {
                const now = Date.now();
                debugger;
                const diff = Date.now() - now;
                if (diff > threshold) {
                    if (!devtools.isOpen) { emitEvent(true); }
                    devtools.isOpen = true;
                } else {
                    if (devtools.isOpen) { emitEvent(false); }
                    devtools.isOpen = false;
                }
            };
            main({emitEvents: false});
            setInterval(main, 500);
            window.addEventListener('devtoolschange', event => {
                if (event.detail.isOpen) {
                    document.body.innerHTML = `<div style="background-color: #000; color: red; position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 9999; display: flex; justify-content: center; align-items: center; font-size: 24px; font-family: sans-serif;">PH√ÅT HI·ªÜN H√ÄNH VI C·ªê T√åNH CAN THI·ªÜP H·ªÜ TH·ªêNG!</div>`;
                    setTimeout(() => { window.location.href = 'index.html'; }, 1500);
                }
            });
            window.addEventListener('contextmenu', e => e.preventDefault(), false);
            window.addEventListener('keydown', e => {
                if (e.keyCode === 123 || (e.ctrlKey && e.shiftKey && (e.keyCode === 73 || e.keyCode === 74)) || (e.ctrlKey && e.keyCode === 85)) {
                    e.preventDefault();
                }
            });
        })();
    </script>

    <style>
        /* === Bi·∫øn m√†u & Reset CSS === */
        :root {
            /* Bi·∫øn cho Tool d·ª± ƒëo√°n */
            --bg-color: #0d1117;
            --primary-gold: #ffd700;
            --text-light: #e6edf3;
            --text-secondary: #a0a0a0;
            --card-bg: rgba(28, 35, 43, 0.8);
            --border-color: rgba(255, 215, 0, 0.3);
            --highlight-blue: #4dccff;
            --exit-btn-bg: linear-gradient(135deg, #ff416c, #ff4b2b);

            /* Bi·∫øn cho m√†n h√¨nh Login (ENHANCED) */
            --primary-neon: #00ffea;
            --secondary-glow: #ff00ff;
            --dark-bg-login: #050a0f;
            --glow-color: rgba(0, 255, 234, 0.75);
            --grid-color: rgba(0, 255, 234, 0.1);
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        .hidden { display: none !important; }

        /* === Body & M√†n h√¨nh Login (ENHANCED) === */
        body {
            background-color: var(--dark-bg-login);
            color: #e0e0e0;
            font-family: 'Orbitron', sans-serif;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow: hidden;
            background-image: 
                linear-gradient(var(--grid-color) 1px, transparent 1px),
                linear-gradient(90deg, var(--grid-color) 1px, transparent 1px);
            background-size: 40px 40px;
            animation: moveGrid 10s linear infinite;
        }
        
        body.game-active {
            font-family: 'Poppins', sans-serif;
            background: var(--bg-color);
            color: var(--text-light);
            overflow: hidden;
            animation: none; /* T·∫Øt animation l∆∞·ªõi */
        }

        .login-container {
            position: relative; z-index: 2; padding: 20px; width: 100%;
        }

        .entry-form {
            background: rgba(13, 17, 23, 0.9);
            border: 2px solid var(--primary-neon);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border-radius: 12px; padding: 40px; width: 90%; max-width: 450px;
            margin: 0 auto;
            box-shadow: 0 0 20px var(--glow-color), 0 0 40px rgba(0, 255, 234, 0.5), inset 0 0 10px var(--primary-neon);
            transition: all 0.3s ease;
        }

        .title {
            font-size: clamp(30px, 6vw, 40px); color: #fff; text-transform: uppercase;
            letter-spacing: 4px; text-align: center;
            text-shadow: 0 0 10px var(--primary-neon), 0 0 20px var(--secondary-glow);
            margin-bottom: 35px; border-bottom: 2px solid rgba(0, 255, 234, 0.3); padding-bottom: 15px;
        }

        .input-group { margin-bottom: 30px; }
        .input-group input {
            padding: 15px 20px; width: 100%; border: 1px solid var(--secondary-glow);
            border-radius: 8px; background-color: rgba(0, 0, 0, 0.6); color: var(--primary-neon);
            font-family: 'Poppins', sans-serif; font-size: 17px; outline: none; transition: all 0.3s ease;
        }
        .input-group input:focus { 
            border-color: var(--primary-neon); 
            box-shadow: 0 0 15px var(--glow-color); 
            background-color: rgba(0, 0, 0, 0.8);
        }
        .input-group input::placeholder { color: rgba(255, 255, 255, 0.5); font-style: italic; }

        .submit-button {
            display: block; padding: 15px 20px; 
            background: linear-gradient(90deg, var(--primary-neon), var(--secondary-glow));
            border: none; border-radius: 8px; color: #050a0f;
            font-weight: 700; font-size: 20px; font-family: 'Orbitron', sans-serif;
            text-transform: uppercase; cursor: pointer; transition: all 0.3s ease;
            width: 100%; letter-spacing: 3px; 
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 15px rgba(0, 255, 234, 0.5);
        }
        .submit-button:hover {
            box-shadow: 0 0 30px var(--glow-color), 0 0 50px var(--secondary-glow);
            transform: scale(1.02);
        }

        /* === Giao di·ªán Tool & Game === */
        iframe { position: fixed; top: 0; left: 0; width: 100%; height: 100%; border: none; z-index: 1; }
        
        #robotBox {
            position: fixed; top: 80px; left: 20px; z-index: 9999; user-select: none;
            display: flex; align-items: flex-start; gap: 12px; cursor: move;
            touch-action: none; animation: float 3s ease-in-out infinite;
        }
        #robotIcon {
            width: 70px; height: auto; object-fit: contain;
            filter: drop-shadow(0 0 10px rgba(255, 215, 0, 0.5));
        }
        
        #predictionCard {
            background: var(--card-bg); backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px); color: var(--text-light);
            padding: 12px 18px; border-radius: 20px; max-width: 300px;
            border: 1px solid var(--border-color); box-shadow: 0 4px 30px rgba(0, 0, 0, 0.2);
            font-size: 14px; text-align: left;
        }
        #phien { font-size: 16px; font-weight: 700; color: var(--primary-gold); text-shadow: 0 0 5px rgba(255, 215, 0, 0.7); }
        /* TƒÉng c·ª° ch·ªØ cho ph·∫ßn d·ª± ƒëo√°n ch√≠nh */
        #duDoan { margin-top: 5px; font-size: 15px; line-height: 1.4; font-weight: 700; } 
        #cauStatus { margin-top: 8px; font-size: 12px; color: var(--text-secondary); }
        #copyright {
            position: fixed; bottom: 10px; right: 10px; color: var(--text-secondary); font-size: 11px;
            background: rgba(13, 17, 23, 0.6); padding: 4px 8px; border-radius: 5px;
            z-index: 9999; user-select: none; opacity: 0.7;
        }
        .back-btn {
            display: flex; align-items: center; gap: 8px; position: fixed; top: 15px; left: 15px;
            padding: 10px 20px; background: var(--exit-btn-bg); color: white; font-weight: 600;
            font-size: 15px; text-decoration: none; border: none; border-radius: 50px;
            cursor: pointer; z-index: 10000; box-shadow: 0 5px 20px rgba(255, 65, 108, 0.4);
            transition: all 0.3s ease; user-select: none;
        }
        .back-btn:hover {
            transform: translateY(-3px) scale(1.05); box-shadow: 0 8px 25px rgba(255, 75, 43, 0.6);
        }
        
        /* C·∫¨P NH·∫¨T M√ÄU CHO D·ª∞ ƒêO√ÅN */
        .du-doan-tai { color: #ff5757 !important; }
        .du-doan-xiu { color: #4dccff !important; }
        .ty-le { color: var(--primary-gold); font-weight: 700; }

        /* === Keyframes (C·∫≠p nh·∫≠t cho hi·ªáu ·ª©ng nh·∫•p nh√°y t·ª∑ l·ªá) === */
        @keyframes float { 0% { transform: translateY(0px); } 50% { transform: translateY(-8px); } 100% { transform: translateY(0px); } }
        @keyframes moveGrid { from { background-position: 0 0; } to { background-position: -80px -80px; } }
        @keyframes pulseGlow {
            from { box-shadow: 0 0 10px var(--glow-color), 0 0 20px var(--glow-color), inset 0 0 5px var(--primary-neon); }
            to { box-shadow: 0 0 20px var(--glow-color), 0 0 40px var(--glow-color), inset 0 0 10px var(--primary-neon); }
        }
        @keyframes glitch { 2%, 64% { transform: translate(2px, 0) skew(0deg); } 4%, 60% { transform: translate(-2px, 0) skew(0deg); } 62% { transform: translate(0, 0) skew(5deg); } }
        @keyframes blinkGlow { 
            0%, 100% { opacity: 1; transform: scale(1.0); } 
            50% { opacity: 0.7; transform: scale(1.05); } 
        }
        .glow-blink {
            animation: blinkGlow 1.5s ease-in-out infinite;
        }
    </style>
</head>
<body>

<script>
    // --- C∆† CH·∫æ X√ÅC TH·ª∞C M·ªöI (Gi·ªØ nguy√™n) ---
    (function() {
        const userJson = sessionStorage.getItem('currentUser');
        let user = userJson ? JSON.parse(userJson) : null;

        if (!user || !user.activeKey) {
            document.body.style.display = 'none';
            Swal.fire({
                background: '#0a0a0f', color: '#00ffea', title: 'ACCESS DENIED',
                text: 'Authentication required. Redirecting to login...', icon: 'error',
                iconColor: '#ff00ff', confirmButtonText: 'OK', confirmButtonColor: '#ff00ff',
                timer: 2500, allowOutsideClick: false, showConfirmButton: false, timerProgressBar: true,
                customClass: { popup: 'swal-wide' }
            }).then(() => { window.location.href = 'index.html'; });
            const style = document.createElement('style');
            style.innerHTML = `.swal-progress-bar-hacker { background-color: #ff00ff !important; }`;
            document.head.appendChild(style);
            throw new Error("Authentication failed. Halting script execution.");
        }
    })();
</script>

<div class="login-container" id="login-screen">
    <div class="entry-form">
        <h1 class="title">H·ªÜ TH·ªêNG D·ª∞ ƒêO√ÅN V.I.P</h1>
        <form id="entry-form">
            <div class="input-group">
                <input type="url" id="linkInput" placeholder="Nh·∫≠p link game Lucky Win..." required/>
            </div>
            <button type="submit" class="submit-button">
                <span>KICK-START ‚ö°Ô∏è</span>
            </button>
        </form>
    </div>
</div>

<div id="game-screen" class="hidden">
    <a href="menugame.html" class="back-btn">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
            <path fill-rule="evenodd" d="M15 8a.5.5 0 0 0-.5-.5H2.707l3.147-3.146a.5.5 0 1 0-.708-.708l-4 4a.5.5 0 0 0 0 .708l4 4a.5.5 0 0 0 .708-.708L2.707 8.5H14.5A.5.5 0 0 0 15 8"/>
        </svg>
        Quay l·∫°i Menu
    </a>

    <iframe id="gameIframe" src="" allowfullscreen></iframe>

    <div id="robotBox" title="K√©o th·∫£ khung d·ª± ƒëo√°n">
        <img id="robotIcon" src="https://i.postimg.cc/1zLnNsCZ/IMG-3575.gif" alt="Robot" />
        <div id="predictionCard">
            <div id="phien">#...</div>
            <div id="duDoan">ƒêang kh·ªüi ƒë·ªông...</div>
            <div id="cauStatus">...</div>
        </div>
    </div>

    <audio id="soundTai" src="https://assets.mixkit.co/sfx/preview/mixkit-game-ball-tap-2073.mp3" preload="auto"></audio>
    <audio id="soundXiu" src="https://assets.mixkit.co/sfx/preview/mixkit-game-click-1114.mp3" preload="auto"></audio>

    <div id="copyright"></div>
</div>

<script>
    const LUCK_API = "luck.php";
    let lastUpdatedPhien = null;
    let predictionTimeoutId = null;
    const PREDICTION_DELAY_MS = 2000; 
    
    // =================================================================================
    // 5 THU·∫¨T TO√ÅN C·ªêT L√ïI M·ªöI (VIP PRO ALGORITHMS) - GI·ªÆ NGUY√äN
    // =================================================================================

    // ‚≠ê ALGO 1: MATRIX COUNTER (Ph√¢n t√≠ch c√¢n b·∫±ng theo c·∫∑p 3 g·∫ßn nh·∫•t)
    function algo1_matrixCounter(results, n = 9) {
        if (results.length < n) return results.at(-1) || "T√†i";
        const recent = results.slice(-n); // Ph√¢n t√≠ch 9 phi√™n g·∫ßn nh·∫•t
        let taiCount = 0;
        let xiuCount = 0;
        
        for (let i = 0; i < n - 2; i += 3) {
            const block = recent.slice(i, i + 3);
            if (block.length === 3) {
                const T = block.filter(r => r === 'T√†i').length;
                const X = 3 - T;
                if (T > X) taiCount++;
                else if (X > T) xiuCount++;
            }
        }
        
        if (taiCount > xiuCount) return "T√†i";
        if (xiuCount > taiCount) return "X·ªâu";
        
        // N·∫øu c√¢n b·∫±ng, theo d√µi xu h∆∞·ªõng ng·∫Øn
        return results.at(-1) || "T√†i";
    }

    // ‚≠ê ALGO 2: FLASH 3-CHAIN PREDICTOR (D·ª± ƒëo√°n xu h∆∞·ªõng c·ª±c ng·∫Øn v√† ch·ªëng b·ªát ng·∫Øn)
    function algo2_flash3Chain(results) {
        if (results.length < 3) return results.at(-1) || "T√†i";
        const [r3, r2, r1] = results.slice(-3);
        
        // C·∫•u tr√∫c 3-1: TXXT -> T (B·ªát 3) -> D·ª± ƒëo√°n ph√° b·ªát: X
        if (r1 === r2 && r1 !== r3) { 
            return r1 === "T√†i" ? "X·ªâu" : "T√†i";
        }
        
        // C·∫•u tr√∫c 1-1-1: TXT -> X (1-1 ti·∫øp)
        if (r1 !== r2 && r2 !== r3) {
            return r1 === "T√†i" ? "X·ªâu" : "T√†i";
        }

        // M·∫∑c ƒë·ªãnh b·ªát (T-T-T) -> Ph√° b·ªát: X
        if (r1 === r2 && r2 === r3) {
            return r1 === "T√†i" ? "X·ªâu" : "T√†i"; 
        }

        return results.at(-1) || "T√†i";
    }

    // ‚≠ê ALGO 3: ANTI-REVERSE MOMENTUM (NgƒÉn ch·∫∑n vi·ªác ƒë·∫£o c·∫ßu li√™n t·ª•c)
    function algo3_antiReverseMomentum(results, chainLength = 6) {
        if (results.length < chainLength) return results.at(-1) || "T√†i";
        const lastChain = results.slice(-chainLength);
        
        let alternatingCount = 0;
        for (let i = 1; i < chainLength; i++) {
            if (lastChain[i] !== lastChain[i - 1]) {
                alternatingCount++;
            }
        }
        
        // N·∫øu c√≥ 5 ho·∫∑c 6 l·∫ßn ƒë·ªïi chi·ªÅu (1-1 d√†i: TXTX ho·∫∑c TXT)
        if (alternatingCount >= 5) {
            // ƒê√£ qu√° 1-1, d·ª± ƒëo√°n k·∫øt qu·∫£ hi·ªán t·∫°i b·ªát ti·∫øp
            return results.at(-1) || "T√†i"; 
        }
        
        return results.at(-1) === 'T√†i' ? 'X·ªâu' : 'T√†i'; // M·∫∑c ƒë·ªãnh ƒë·∫£o
    }

    // ‚≠ê ALGO 4: HIGH DEVIATION BREAK (Ph√° c·∫ßu b·ªát v∆∞·ª£t m·ª©c)
    function algo4_highDeviationBreak(results, minLen = 5, historyLen = 20) {
        if (results.length < historyLen) return results.at(-1) || "T√†i";
        
        const last = results.at(-1);
        let currentChain = 0;
        for (let i = results.length - 1; i >= 0; i--) {
            if (results[i] === last) currentChain++;
            else break;
        }

        // N·∫øu c·∫ßu hi·ªán t·∫°i ch∆∞a ƒë·ªß d√†i ƒë·ªÉ x√©t (v√≠ d·ª• < 5)
        if (currentChain < minLen) return last;

        const recent = results.slice(-historyLen);
        const maxTaiChain = recent.reduce((max, curr, i, arr) => (curr === 'T√†i' && arr[i-1] !== 'T√†i' ? Math.max(max, arr.slice(i).findIndex(r => r !== 'T√†i')) : max), 0) || 0;
        const maxXiuChain = recent.reduce((max, curr, i, arr) => (curr === 'X·ªâu' && arr[i-1] !== 'X·ªâu' ? Math.max(max, arr.slice(i).findIndex(r => r !== 'X·ªâu')) : max), 0) || 0;

        const maxObservedChain = Math.max(maxTaiChain, maxXiuChain);
        
        // N·∫øu c·∫ßu hi·ªán t·∫°i v∆∞·ª£t qu√° 1.5 l·∫ßn c·∫ßu d√†i nh·∫•t ƒë√£ t·ª´ng th·∫•y -> Ph√° c·∫ßu
        if (currentChain > maxObservedChain * 1.5 && currentChain > 7) {
            return last === 'T√†i' ? 'X·ªâu' : 'T√†i';
        }

        return last; // N·∫øu ch∆∞a ƒë·ªß d√†i/qu√° m·ª©c, ti·∫øp t·ª•c b·ªát
    }

    // ‚≠ê ALGO 5: FINAL SHORT-TERM SWING (L∆∞·ªõt theo dao ƒë·ªông ng·∫Øn h·∫°n 2 phi√™n)
    function algo5_finalShortTermSwing(results) {
        if (results.length < 2) return results.at(-1) || "T√†i";
        const last = results.at(-1);
        const secondLast = results.at(-2);
        
        // N·∫øu ƒëang l√† c·∫ßu b·ªát 2 (T-T, X-X) -> Ti·∫øp t·ª•c b·ªát
        if (last === secondLast) {
            return last; 
        }
        
        // N·∫øu ƒëang l√† c·∫ßu 1-1 (T-X) -> Chuy·ªÉn h∆∞·ªõng
        return last === 'T√†i' ? 'X·ªâu' : 'T√†i';
    }


    // =================================================================================
    // H√ÄM T·ªîNG H·ª¢P V√Ä G·ªåI H√ÄM D·ª∞ ƒêO√ÅN CU·ªêI C√ôNG (HYBRID VOTE)
    // C·∫¨P NH·∫¨T: T·ª∂ L·ªÜ NG·∫™U NHI√äN V5.0
    // =================================================================================

    function hybridVote(results) {
        const data = (results || []).filter(r => r === "T√†i" || r === "X·ªâu");
        
        // TR·ªåNG S·ªê CHO 5 THU·∫¨T TO√ÅN VIP PRO
        const algorithms = [
            { func: algo1_matrixCounter, weight: 25 },
            { func: algo2_flash3Chain, weight: 20 },
            { func: algo3_antiReverseMomentum, weight: 25 },
            { func: algo4_highDeviationBreak, weight: 15 },
            { func: algo5_finalShortTermSwing, weight: 15 }
        ];
        
        let taiScore = 0;
        let xiuScore = 0;
        let totalWeight = 0;
        
        for (const algo of algorithms) {
            const result = algo.func(data);
            totalWeight += algo.weight;
            if (result === "T√†i") taiScore += algo.weight; 
            else xiuScore += algo.weight;
        }

        const finalPrediction = taiScore >= xiuScore ? "T√†i" : "X·ªâu";
        const winningScore = Math.max(taiScore, xiuScore);
        const losingScore = Math.min(taiScore, xiuScore);

        let finalProbability = 0;
        
        if (totalWeight > 0) {
            // T√çNH TO√ÅN X√ÅC SU·∫§T C∆† B·∫¢N (T·ª∂ L·ªÜ TH√î)
            finalProbability = (winningScore / totalWeight) * 100;
        } else {
            finalProbability = 50.0;
        }
        
        // --- C∆† CH·∫æ TƒÇNG C∆Ø·ªúNG ƒê·ªò PH√ÇN C·ª∞C (POLARIZATION) V√Ä L√ÄM ƒê·∫∏P T·ª∂ L·ªÜ ---
        if (data.length >= 30) {
            const deviation = Math.abs(finalProbability - 50.0); 
            // H·ªÜ S·ªê PH√ÇN C·ª∞C
            const polarizationFactor = 1.85; 
            
            // √Åp d·ª•ng h√†m m≈© (tƒÉng t·ªëc) cho ƒë·ªô l·ªách
            const polarizedDeviation = Math.min(50, Math.pow(deviation, polarizationFactor) / Math.pow(50, polarizationFactor - 1));
            
            // T√≠nh to√°n l·∫°i t·ª∑ l·ªá cu·ªëi c√πng
            if (finalProbability >= 50.0) {
                finalProbability = 50.0 + polarizedDeviation;
            } else {
                finalProbability = 50.0 - polarizedDeviation;
            }
        } else {
            // Khi thi·∫øu d·ªØ li·ªáu (<30 phi√™n), t·ª∑ l·ªá t·ªëi ƒëa l√† 65%
            finalProbability = Math.min(65.0, finalProbability);
        }
        
        // --- B∆Ø·ªöC M·ªöI: NG·∫™U NHI√äN H√ìA TINH VI (SUBTLE RANDOMIZATION) ---
        // Th√™m m·ªôt gi√° tr·ªã ng·∫´u nhi√™n nh·ªè t·ª´ -0.5 ƒë·∫øn +0.5
        const randomShift = (Math.random() - 0.5) * 1.0; 
        finalProbability += randomShift;
        // ƒê·∫£m b·∫£o sau ng·∫´u nhi√™n, t·ª∑ l·ªá v·∫´n h∆∞·ªõng v·ªÅ d·ª± ƒëo√°n chi·∫øn th·∫Øng
        if (finalPrediction === 'T√†i' && finalProbability < 50) finalProbability = 50.1;
        if (finalPrediction === 'X·ªâu' && finalProbability > 50) finalProbability = 49.9;


        // --- GI·ªöI H·∫†N CU·ªêI C√ôNG V√Ä L√ÄM TR√íN ---
        
        finalProbability = Math.min(99.9, finalProbability); 
        finalProbability = Math.max(1.0, finalProbability); 

        // N·∫øu ƒëi·ªÉm T√†i = ƒëi·ªÉm X·ªâu, t·ª∑ l·ªá ph·∫£i l√† 50.0
        if (taiScore === xiuScore || totalWeight === 0) {
            finalProbability = 50.0;
        }
        
        // L√†m tr√≤n ƒë·∫øn 1 ch·ªØ s·ªë th·∫≠p ph√¢n (ƒë·ªÉ t·ª∑ l·ªá tr√¥ng "ƒë·∫πp" h∆°n: 75.1, 82.5, ...)
        finalProbability = Math.round(finalProbability * 10) / 10;
        
        return {
            prediction: finalPrediction,
            probability: finalProbability
        };
    }

    // =================================================================================
    // C√ÅC H√ÄM C√íN L·∫†I (GI·ªÆ NGUY√äN)
    // =================================================================================


    function runTool() {
        // TH√îNG B√ÅO CH√öC B·∫†N TH·∫ÆNG L·ªöN
        Swal.fire({
            background: '#0d1117', color: '#00ffea', title: '‚≠ê K√çCH HO·∫†T H·ªÜ TH·ªêNG VIP PRO V5.0 ‚≠ê',
            html: 'ƒê√£ c·∫≠p nh·∫≠t **Ng·∫´u nhi√™n h√≥a Tinh vi**.<br> **T·ª∑ l·ªá s·∫Ω thay ƒë·ªïi linh ho·∫°t m·ªói phi√™n!**', 
            icon: 'success',
            iconColor: '#ffd700', confirmButtonText: 'B·∫ÆT ƒê·∫¶U', confirmButtonColor: '#00ffea',
            timer: 3000, timerProgressBar: true,
            customClass: { popup: 'swal-wide' }
        });
        
        fetchData();
        // T·∫ßn su·∫•t g·ªçi API 1s
        setInterval(fetchData, 1000); 

        // Logic k√©o th·∫£ robot (Gi·ªØ nguy√™n)
        const box = document.getElementById("robotBox");
        let isDragging = false, offsetX = 0, offsetY = 0;
        const startDrag = (e) => {
            isDragging = true;
            const clientX = e.clientX || e.touches[0].clientX;
            const clientY = e.clientY || e.touches[0].clientY;
            offsetX = clientX - box.offsetLeft;
            offsetY = clientY - box.offsetTop;
        };
        const drag = (e) => {
            if (isDragging) {
                e.preventDefault();
                const clientX = e.clientX || e.touches[0].clientX;
                const clientY = e.clientY || e.touches[0].clientY;
                box.style.left = (clientX - offsetX) + "px";
                box.style.top = (clientY - offsetY) + "px";
            }
        };
        const endDrag = () => { isDragging = false; };
        box.addEventListener("mousedown", startDrag);
        document.addEventListener("mousemove", drag);
        document.addEventListener("mouseup", endDrag);
        box.addEventListener("touchstart", startDrag, { passive: false });
        document.addEventListener("touchmove", drag, { passive: false });
        document.addEventListener("touchend", endDrag);
    }
    
    async function fetchData() {
        try {
            const apiUrl = LUCK_API + '?t=' + Date.now();  
            const res = await fetch(apiUrl);
            
            if (!res.ok) {
                const errorData = await res.json().catch(() => ({ error: "L·ªói kh√¥ng x√°c ƒë·ªãnh." }));
                throw new Error(errorData.error || `L·ªói HTTP: ${res.status}`);
            }
            
            const rawData = await res.json();
            
            let currentPhien = null;
            let previousResult = null;
            let fullHistory = [];

            // X·ª≠ l√Ω d·ªØ li·ªáu API
            if (Array.isArray(rawData)) {
                const latestCompletedSession = rawData.find(item => item.phien && item.ket_qua);
                if (latestCompletedSession) {
                    currentPhien = latestCompletedSession.phien;
                    previousResult = latestCompletedSession.ket_qua;
                    fullHistory = rawData
                        .map(item => item.ket_qua)
                        .filter(r => r === 'T√†i' || r === 'X·ªâu')
                        .reverse(); 
                }
            } else if (typeof rawData === 'object' && rawData !== null) {
                if (rawData.phien && rawData.ket_qua) {
                    currentPhien = rawData.phien;
                    previousResult = rawData.ket_qua;
                }
                if (Array.isArray(rawData.history)) {
                    fullHistory = rawData.history
                        .filter(r => r === 'T√†i' || r === 'X·ªâu')
                        .reverse();
                } else {
                    fullHistory = [previousResult].filter(r => r === 'T√†i' || r === 'X·ªâu');
                }
            }
            
            if (currentPhien && previousResult) {
                
                const historyForAlgo = fullHistory.slice(-100);

                if (currentPhien !== lastUpdatedPhien) {
                    
                    lastUpdatedPhien = currentPhien;
                    
                    const phienDuDoan = parseInt(currentPhien) + 1;

                    if (predictionTimeoutId) clearTimeout(predictionTimeoutId);

                    // C·∫≠p nh·∫≠t giao di·ªán t·∫°m th·ªùi (ƒêang ch·ªù ph√¢n t√≠ch)
                    document.getElementById("phien").innerText = `#${phienDuDoan}`;
                    const duDoanEl = document.getElementById("duDoan");
                    duDoanEl.innerHTML = '<span style="color:#ffc107;">ƒêang T√çNH TO√ÅN VIP PRO...</span>';
                    duDoanEl.classList.remove("du-doan-tai", "du-doan-xiu");
                    document.getElementById("cauStatus").innerText = `L·ªãch s·ª≠ g·∫ßn nh·∫•t: ${historyForAlgo.slice(-4).join('-')} (${historyForAlgo.length} phi√™n)`; 

                    // T·∫°o hi·ªáu ·ª©ng tr·ªÖ 2 gi√¢y tr∆∞·ªõc khi hi·ªán k·∫øt qu·∫£ ch√≠nh th·ª©c (G·ªåI HYBRID VOTE)
                    predictionTimeoutId = setTimeout(() => {
                        const duDoanResult = hybridVote(historyForAlgo);
                        const predictedValue = duDoanResult.prediction;
                        const probability = duDoanResult.probability;

                        updateDuDoanUI_Enhanced( // S·ª≠ d·ª•ng h√†m hi·ªÉn th·ªã n√¢ng cao
                            predictedValue, 
                            `T·ª∑ l·ªá: ${probability}% | C·∫ßu: ${historyForAlgo.slice(-4).join('-')}...`
                        );
                        predictionTimeoutId = null;
                    }, PREDICTION_DELAY_MS);
                }
            } else {
                throw new Error("D·ªØ li·ªáu phi√™n kh√¥ng h·ª£p l·ªá. Vui l√≤ng ki·ªÉm tra API.");
            }
        } catch (err) {
            console.error("L·ªói khi fetch d·ªØ li·ªáu:", err.message);
            document.getElementById("duDoan").innerHTML = `<span style="color:#ff003c;">API Error.</span>`;
            document.getElementById("cauStatus").innerText = `L·ªói k·∫øt n·ªëi: ${err.message}`;
            if (predictionTimeoutId) clearTimeout(predictionTimeoutId);
            predictionTimeoutId = null;
        }
    }

    // ‚≠ê H√ÄM UPDATE GIAO DI·ªÜN N√ÇNG CAO (ƒê√É S·ª¨A L·∫†I ·ªû Y√äU C·∫¶U TR∆Ø·ªöC) ‚≠ê
    function updateDuDoanUI_Enhanced(prediction, status) {
        const duDoanEl = document.getElementById("duDoan");
        
        // X√≥a t·∫•t c·∫£ c√°c l·ªõp m√†u c≈©
        duDoanEl.classList.remove("du-doan-tai", "du-doan-xiu", "glow-blink");
        
        const probabilityMatch = status.match(/T·ª∑ l·ªá: ([\d.]+)%/);
        const probability = probabilityMatch ? parseFloat(probabilityMatch[1]) : 0;
        
        let resultHTML = '';
        let glowStyle = '';
        let emoji = '';

        // Thi·∫øt l·∫≠p m√†u v√† bi·ªÉu t∆∞·ª£ng
        if (prediction === "T√†i") {
            emoji = 'üî•';
            duDoanEl.classList.add("du-doan-tai");
            glowStyle = 'text-shadow: 0 0 8px #ff0000, 0 0 15px #ff5757;'; // Hi·ªáu ·ª©ng ƒë·ªè m·∫°nh
            document.getElementById("soundTai").play().catch(() => {});
        } else if (prediction === "X·ªâu") {
            emoji = '‚ùÑÔ∏è';
            duDoanEl.classList.add("du-doan-xiu");
            glowStyle = 'text-shadow: 0 0 8px #00aaff, 0 0 15px #4dccff;'; // Hi·ªáu ·ª©ng xanh m·∫°nh
            document.getElementById("soundXiu").play().catch(() => {});
        } 

        // Ki·ªÉm tra t·ª∑ l·ªá c·ª±c cao ƒë·ªÉ th√™m hi·ªáu ·ª©ng nh·∫•p nh√°y
        if (probability >= 90.0 || probability <= 10.0) {
            duDoanEl.classList.add("glow-blink"); 
        }

        // T·∫°o HTML k·∫øt qu·∫£
        resultHTML = `
            D·ª∞ ƒêO√ÅN: ${emoji} ${prediction.toUpperCase()} ${emoji} 
            <br>
            <strong 
                class="ty-le" 
                style="font-size: 1.8em; display: block; margin-top: 8px; ${glowStyle}"
            >
                ${probability.toFixed(1)}%
            </strong>
        `;

        duDoanEl.innerHTML = resultHTML;

        // C·∫≠p nh·∫≠t tr·∫°ng th√°i (l·ªãch s·ª≠ ng·∫Øn)
        document.getElementById("cauStatus").innerText = status.replace(/T·ª∑ l·ªá: ([\d.]+)% \| /, ''); 
    }

    // --- Logic chuy·ªÉn ƒë·ªïi giao di·ªán (Gi·ªØ nguy√™n) ---
    document.getElementById('entry-form').addEventListener('submit', function(e) {
        e.preventDefault();
        
        const gameLink = document.getElementById('linkInput').value;

        if (!gameLink.trim()) {
            alert("Vui l√≤ng nh·∫≠p link game!");
            return;
        }

        document.getElementById('gameIframe').src = gameLink;

        document.getElementById('login-screen').classList.add('hidden');
        document.body.classList.add('game-active');
        document.getElementById('game-screen').classList.remove('hidden');

        // Kh·ªüi ch·∫°y tool d·ª± ƒëo√°n
        runTool();
    });
    
    // Kh·ªüi t·∫°o Copyright
    document.getElementById('copyright').innerText = `¬© 2024 LUCKY WIN PREDICTION TOOL | Dev: ${JSON.parse(sessionStorage.getItem('currentUser'))?.name || 'Vip'}`;
</script>

</body>
</html>